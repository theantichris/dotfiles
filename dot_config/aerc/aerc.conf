# aerc main configuration

[general]
term=wezterm

[ui]
next-message-on-delete=false
auto-mark-read=true
auto-mark-read-split=true
auto-mark-read-split-delay=3s

# The directories where the stylesets are stored. It takes a colon-separated
# list of directories. If this is unset or if a styleset cannot be found, the
# following paths will be used as a fallback in that order:
#
#   ${XDG_CONFIG_HOME:-~/.config}/aerc/stylesets
#   ${XDG_DATA_HOME:-~/.local/share}/aerc/stylesets
#   /usr/local/share/aerc/stylesets
#   /usr/share/aerc/stylesets
#
#stylesets-dirs=

# Uncomment to use box-drawing characters for vertical and horizontal borders.
#
# Default: "│" and "─"
#border-char-vertical="│"
#border-char-horizontal="─"

# Sets the styleset to use for the aerc ui elements.
#
# Default: default
#styleset-name=default

# Positions the cursor on the last message in the message list (at the
# bottom of the view) when opening a new folder.
#
# Default: false
#select-last-message=false

[statusline]
#
# Describes the format for the status line. This is a comma separated list of
# column names with an optional align and width suffix. See [ui].index-columns
# for more details. To completely mute the status line except for push
# notifications, explicitly set status-columns to an empty string.
#
# Default: left<*,center:=,right>*
#status-columns=left<*,center:=,right>*

#
# Each name in status-columns must have a corresponding column-$name setting.
# All column-$name settings accept golang text/template syntax. See
# aerc-templates(7) for available template attributes and functions.
#
# Default settings
#column-left=[{{.Account}}] {{.StatusInfo}}
#column-center={{.PendingKeys}}
#column-right={{.TrayInfo}} | {{cwd}}

#
# String separator inserted between columns.
# See [ui].column-separator for more details.
#
#column-separator=" "

# Specifies the separator between grouped statusline elements.
#
# Default: " | "
#separator=" | "

# Defines the mode for displaying the status elements.
# Options: text, icon
#
# Default: text
#display-mode=text

[viewer]
text/html = w3m -T text/html -o display_images=1 -o auto_image=1
alternatives=text/html,text/plain

[compose]
editor=helix
focus-body=true
empty-subject-warning=true

# Specifies the command to be used to select attachments. Any occurrence of
# '%s' in the file-picker-cmd will be replaced with the argument <arg>
# to :attach -m <arg>. Any occurrence of '%f' will be replaced by the
# location of a temporary file, from which aerc will read the selected files.
#
# If '%f' is not present, the command must output the selected files to
# standard output, one file per line. If it is present, then aerc does not
# capture the standard output and instead reads the files from the temporary
# file which should have the same format.
#file-picker-cmd=


[filters]
.headers=colorize

#
# Filters allow you to pipe an email body through a shell command to render
# certain emails differently, e.g. highlighting them with ANSI escape codes.
#
# The commands are invoked with sh -c. The following folders are prepended to
# the system $PATH to allow referencing filters from their name only:
#
#   ${XDG_CONFIG_HOME:-~/.config}/aerc/filters
#   ~/.local/libexec/aerc/filters
#   ${XDG_DATA_HOME:-~/.local/share}/aerc/filters
#   $PREFIX/libexec/aerc/filters
#   $PREFIX/share/aerc/filters
#   /usr/libexec/aerc/filters
#   /usr/share/aerc/filters
#
# If you want to run a program in your default $PATH which has the same name
# as a builtin filter (e.g. /usr/bin/colorize), use its absolute path.
#
# The following variables are defined in the filter command environment:
#
#   AERC_MIME_TYPE      the part MIME type/subtype
#   AERC_FORMAT         the part content type format= parameter
#   AERC_FILENAME       the attachment filename (if any)
#   AERC_SUBJECT        the message Subject header value
#   AERC_FROM           the message From header value
#
# The first filter which matches the email's mimetype will be used, so order
# them from most to least specific.
#
# You can also match on non-mimetypes, by prefixing with the header to match
# against (non-case-sensitive) and a comma, e.g. subject,text will match a
# subject which contains "text". Use header,~regex to match against a regex.
#
text/plain=colorize
text/calendar=calendar
message/delivery-status=colorize
message/rfc822=colorize
#text/html=pandoc -f html -t plain | colorize
text/html=! html
#text/html=! w3m -T text/html -I UTF-8
#text/*=bat -fP --file-name="$AERC_FILENAME"
#application/x-sh=bat -fP -l sh
#image/*=catimg -w $(tput cols) -
#subject,~Git(hub|lab)=lolcat -f
#from,thatguywhodoesnothardwraphismessages=wrap -w 100 | colorize

[openers]
#
# Openers allow you to specify the command to use for the :open and :open-link
# actions on a per-MIME-type basis. The :open-link URL scheme is used to
# determine the MIME type as follows: x-scheme-handler/<scheme>.
#
# {} is expanded as the temporary filename or URL to be opened with proper
# shell quoting. If it is not encountered in the command, the filename/URL will
# be appended to the end of the command. The command will then be executed with
# `sh -c`.
#
# Like [filters], openers support basic shell globbing. The first opener which
# matches the part's MIME type (or URL scheme handler MIME type) will be used,
# so order them from most to least specific.
#
# Examples:
# x-scheme-handler/irc=hexchat
# x-scheme-handler/http*=printf '%s' {} | wl-copy
# text/html=surf -dfgms
# text/plain=gvim {} +125
# message/rfc822=thunderbird
